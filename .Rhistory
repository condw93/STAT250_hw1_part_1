boot1(20)
warnings()
mean.intercept = mean(models$Coef[1])
source('~/R Data/boot_func.R')
boot1(20)
boot1(20)
warnings()
source('~/R Data/boot_func.R')
source('~/R Data/boot_func.R')
boot1(20)
source('~/R Data/boot_func.R')
boot1(20)
source('~/R Data/boot_func.R')
boot1(20)
source('~/R Data/boot_func.R')
boot1(20)
source('~/R Data/boot_func.R')
t = lm(y~x, data = deviceA)
class(t)
type(t)
source('~/R Data/boot_func.R')
boot1(20)
source('~/R Data/boot_func.R')
boot1(20)
?mean
?lm
source('~/R Data/boot_func.R')
boot1(20)
?warnings
warnings()
source('~/R Data/boot_func.R')
warnings()
boot1(20)
warnings()
source('~/R Data/boot_func.R')
source('~/R Data/boot_func.R')
boot1(20)
source('~/R Data/boot_func.R')
boot1(20)
?array
?confint
return (models)
source('~/R Data/boot_func.R')
boot1(20)
source('~/R Data/boot_func.R')
boot1(20)
?warnings
warnings()
source('~/R Data/boot_func.R')
boot1(20)
return (models$coef[1])
source('~/R Data/boot_func.R')
source('~/R Data/boot_func.R')
boot1(20)
?list
source('~/R Data/boot_func.R')
boot1(20)
source('~/R Data/boot_func.R')
boot1(20)
sample.d = devices[sample(nrow(devices), size = 10000, replace = TRUE),]
weight.d = sample.d$weights/sum(sample.d$weights)
weight.d
models = lm(sample.d$y ~ sample.d$x, weights = weight.d)
models
beta0[i] = models$coef[1]
models$coef[1]
models$coef[2]
beta0 = models$coef[1]
beta0
source('~/R Data/boot_func.R')
boot1(20)
source('~/R Data/boot_func.R')
boot1(20)
source('~/R Data/boot_func.R')
source('~/R Data/boot_func.R')
boot1(20)
source('~/R Data/boot_func.R')
boot1(20)
source('~/R Data/boot_func.R')
boot1(20)
warnings()
source('~/R Data/boot_func.R')
boot1(20)
source('~/R Data/boot_func.R')
boot1(20)
source('~/R Data/boot_func.R')
source('~/R Data/boot_func.R')
boot1(20)
n
models
n
beta9
beta0
beta1
n
n
n
n
beta0
n
weight.d
n
models
models[1]
n
models
n
beta0[1]
beta0[2]
n
n
n
n
n
n
n
n
beta0[1]
beta0[2]
q
q
q
Q
source('~/R Data/boot_func.R')
source('~/R Data/boot_func.R')
boot1(20)
Q
boot1(20)
Q
source('~/R Data/boot_func.R')
boot1(20)
source('~/R Data/boot_func.R')
boot1(20)
rm(beta0)
source('~/R Data/boot_func.R')
boot1(20)
source('~/R Data/boot_func.R')
source('~/R Data/boot_func.R')
boot1(20)
source('~/R Data/boot_func.R')
boot1(20)
source('~/R Data/boot_func.R')
source('~/R Data/boot_func.R')
boot1(20)
source('~/R Data/boot_func.R')
boot1(20)
source('~/R Data/boot_func.R')
return (beta1)
boot1(20)
source('~/R Data/boot_func.R')
boot1(20)
boot1(20)
source('~/R Data/boot_func.R')
source('~/R Data/boot_func.R')
step1(2)
step1(20)
source('~/R Data/boot_func.R')
step1(20)
source('~/R Data/boot_func.R')
boot1(20)
source('~/R Data/boot_func.R')
source('~/R Data/boot_func.R')
source('~/R Data/boot_func.R')
?vcov
source('~/R Data/boot_func.R')
source('~/R Data/boot_func.R')
boot1(20)
boot1(1000)
source('~/R Data/boot_func.R')
boot1(100)
source('~/R Data/boot_func.R')
boot1(100)
?matrix
mdat <- matrix(c(1,2,3, 11,12,13), nrow = 2, ncol = 3, byrow = TRUE,
dimnames = list(c("row1", "row2"),
c("C.1", "C.2", "C.3")))
mdat
source('~/R Data/boot_func.R')
source('~/R Data/boot_func.R')
boot1(100)
source('~/R Data/boot_func.R')
boot1(100)
source('~/R Data/boot_func.R')
source('~/R Data/boot_func.R')
rm(mdat)
rm(r)
rm(t)
rm(step1)
source('~/R Data/boot_func.R')
source('~/R Data/boot_func.R')
Estar = devices[sample(nrow(device.lm$residuals), size = 10000, replace = TRUE),]
Estar = sample(nrow(device.lm$residuals), size = 10000, replace = TRUE)
Estar = sample(device.lm$residuals, size = 10000, replace = TRUE)
head(Estar)
devices$RandomResiduals = Estar
View(devices)
devices$RandomResiduals = sample(device.lm$residuals, size = 10000, replace = TRUE)
View(devices)
source('~/R Data/boot_func.R')
source('~/R Data/boot_func.R')
source('~/R Data/boot_func.R')
boot1(20)
source('~/R Data/boot_func.R')
boot2(30, device.lm$coef[1], device.lm$coef[2],device.lm$residuals, devices$x, devices$weights)
source('~/R Data/boot_func.R')
boot2(30, device.lm$coef[1], device.lm$coef[2],device.lm$residuals, devices$x, devices$weights)
source('~/R Data/boot_func.R')
boot2(30, device.lm$coef[1], device.lm$coef[2],device.lm$residuals, devices$x, devices$weights)
source('~/R Data/boot_func.R')
boot2(30, device.lm$coef[1], device.lm$coef[2],device.lm$residuals, devices$x, devices$weights)
boot2(1000, device.lm$coef[1], device.lm$coef[2],device.lm$residuals, devices$x, devices$weights)
source('~/R Data/boot_func.R')
boot1(1000)
source('~/R Data/boot_func.R')
source('~/R Data/boot_func.R')
source('~/R Data/boot_func.R')
source('~/R Data/boot_func.R')
source('~/R Data/boot_func.R')
source('~/R Data/boot_func.R')
?deriv
source('~/R Data/boot_func.R')
source('~/R Data/boot_func.R')
source('~/R Data/boot_func.R')
library(distr)
?DExp
source('~/R Data/boot_func.R')
source('~/R Data/boot_func.R')
source('~/R Data/boot_func.R')
source('~/R Data/boot_func.R')
source('~/R Data/boot_func.R')
source('~/R Data/boot_func.R')
source('~/R Data/boot_func.R')
source('~/R Data/boot_func.R')
source('~/R Data/boot_func.R')
source('~/R Data/boot_func.R')
boot3(1000, device.lm$coef[1], device.lm$coef[2],device.lm$residuals, devicesA$x, devicesB$x devices$weights)
boot3(1000, device.lm$coef[1], device.lm$coef[2],device.lm$residuals, devicesA$x, devicesB$x, devices$weights)
boot3(1000, device.lm$coef[1], device.lm$coef[2],device.lm$residuals, deviceA$x, deviceB$x, devices$weights)
boot3(1000, device.lm$coef[1], device.lm$coef[2],device.lm$residuals, deviceA$x, deviceB$x, devices$weights)
source('~/R Data/boot_func.R')
boot1(2000)
boot2(2000, device.lm$coef[1], device.lm$coef[2],device.lm$residuals, devices$x, devices$weights)
boot3(2000, device.lm$coef[1], device.lm$coef[2],device.lm$residuals, devicesA$x, devicesB$x devices$weights)
boot3(2000, device.lm$coef[1], device.lm$coef[2],device.lm$residuals, devicesA$x, devicesB$x, devices$weights)
boot3(2000, device.lm$coef[1], device.lm$coef[2],device.lm$residuals, deviceA$x, deviceB$x, devices$weights)
library(distr)
boot3(2000, device.lm$coef[1], device.lm$coef[2],device.lm$residuals, deviceA$x, deviceB$x, devices$weights)
source('~/R Data/boot_func.R')
source('~/R Data/boot_func.R')
source('~/R Data/boot_func.R')
source('~/R Data/boot_func.R')
source('~/R Data/boot_func.R')
source('~/R Data/boot_func.R')
bootStrap1(20)
bootStrap2(20)
bootStrap1(20)
bootStrap1(30)
bootStrap2(20, device.lm$coef[1], device.lm$coef[2],device.lm$residuals, devices$x, devices$weights)
bootStrap1(30)
source('~/R Data/boot_func.R')
bootStrap1(30)
source('~/R Data/boot_func.R')
bootStrap2(20, device.lm$coef[1], device.lm$coef[2],device.lm$residuals, devices$x, devices$weights)
summary(device.lm)
table(device.lm)
summary(device.lm)
?confint
confint(device.lm)
confint(device.lm, level = .9)
confint(device.lm, level = .99)
confint(device.lm, level = .975)
confint(device.lm, level = .90)
vcov(device.lm)
source('~/R Data/boot_func.R')
bootStrap3(10, device.lm$coef[1], device.lm$coef[2],device.lm$residuals, deviceA$x, deviceB$x, devices$weights)
source('~/R Data/boot_func.R')
summary(device.lm)
confint(device.lm, level = .90)
vcov(device.lm)
rm(list=ls())
load(url("http://eeyore.ucdavis.edu/stat141/Data/linearModelData.rda"))
install.packages('boot')
install.packages('distr')
library(distr)
## Part Zero
# Sort the data
table(devices$device)
deviceA = devices[devices$device == 'A',]
deviceB = devices[devices$device == 'B',]
row.names(deviceB) = NULL
# Get the residuals for each device
lineA = lm(deviceA$y~deviceA$x)
lineB = lm(deviceB$y~deviceB$x)
# Compute variances of residuals
varA = var(lineA$residuals)
varB = var(lineB$residuals)
# Create weights for each device, make a weight column
weightA = (1/varA)
weightB = (1/varB)
weights = c(rep(weightA, 4000), rep(weightB, 6000))
# Add the weight column to the original dataframes
devices$weights = weights
head(devices)
# Make a model that assumes normality (a linear regression)
device.lm = lm(y~x, data = devices, weight = devices$weights)
summary(device.lm)
confint(device.lm, level = .90)
vcov(device.lm)
# These estimates are the best we can get from the data set, so we will treat them as the population parameters and compare the results of our simulation to those of this regression model to analyze how our simulated estimates measure up
## Part One
bootStrap1(10000)
## Part Two
bootStrap2(10000, device.lm$coef[1], device.lm$coef[2],device.lm$residuals, devices$x, devices$weights)
## Part Three
bootStrap3(10000, device.lm$coef[1], device.lm$coef[2],device.lm$residuals, deviceA$x, deviceB$x, devices$weights)
rm(list=ls())
source('~/R Data/boot_func.R')
load(url("http://eeyore.ucdavis.edu/stat141/Data/linearModelData.rda"))
# install.packages('boot')
# install.packages('distr')
library(distr)
## Part Zero
# Sort the data
table(devices$device)
deviceA = devices[devices$device == 'A',]
deviceB = devices[devices$device == 'B',]
row.names(deviceB) = NULL
# Get the residuals for each device
lineA = lm(deviceA$y~deviceA$x)
lineB = lm(deviceB$y~deviceB$x)
# Compute variances of residuals
varA = var(lineA$residuals)
varB = var(lineB$residuals)
# Create weights for each device, make a weight column
weightA = (1/varA)
weightB = (1/varB)
weights = c(rep(weightA, 4000), rep(weightB, 6000))
# Add the weight column to the original dataframes
devices$weights = weights
head(devices)
# Make a model that assumes normality (a linear regression)
device.lm = lm(y~x, data = devices, weight = devices$weights)
summary(device.lm)
confint(device.lm, level = .90)
vcov(device.lm)
# These estimates are the best we can get from the data set, so we will treat them as the population parameters and compare the results of our simulation to those of this regression model to analyze how our simulated estimates measure up
## Part One
bootStrap1(10000)
bootStrap1(5000)
source('~/R Data/boot_func.R')
bootStrap1(2000)
bootStrap2(2000, device.lm$coef[1], device.lm$coef[2],device.lm$residuals, devices$x, devices$weights)
bootStrap3(2000, device.lm$coef[1], device.lm$coef[2],device.lm$residuals, deviceA$x, deviceB$x, devices$weights)
source('~/R Data/boot_func.R')
source('~/R Data/boot_func.R')
bootStrap1(20)
source('~/R Data/boot_func.R')
source('~/R Data/boot_func.R')
source('~/R Data/boot_func.R')
source('~/R Data/boot_func.R')
source('~/R Data/boot_func.R')
source('~/R Data/boot_func.R')
source('~/R Data/boot_func.R')
source('~/R Data/boot_func.R')
source('~/R Data/boot_func.R')
source('~/R Data/boot_func.R')
### Part One
bootStrap1(5000)
### Part Two
bootStrap2(5000, device.lm$coef[1], device.lm$coef[2],device.lm$residuals, devices$x, devices$weights)
### Part Three
bootStrap3(5000, device.lm$coef[1], device.lm$coef[2],device.lm$residuals, deviceA$x, deviceB$x, devices$weights)
head(devices)
summary(device.lm)
?confint
confint(device.lm, level = .90)
plot(density(device.lm))
plot(density(devices$x))
plot(density(devices$y))
plot(density(devices$y), main = 'Density of Y observations')
vcov(device.lm)
source('~/R Data/boot_func.R')
bootStrap1(20)
source('~/R Data/boot_func.R')
source('~/R Data/boot_func.R')
View(devices)
plot(device.lm)
qqnorm(device.lm$residuals)
rm(list=ls))
rm(list=ls())
# http://www.rfortraders.com/lecture-4-regression-and-pairs-trading/
# http://quanttrader.info/public/testForCoint.html
# http://quanttrader.info/public/betterHedgeRatios.pdf
setwd("~/R Data")
# Load the data for honda and toyota from CSV files. Break it into the training data and the test data. Arrange the
# dataframes by ascending date, starting with the first date and ending with the last. Load 'plyr' package first.
library('plyr')
honda = read.csv('honda.csv', stringsAsFactors = F)
toyota = read.csv('toyota.csv', stringsAsFactors = F)
honda = arrange(honda, increasing = (honda$Date))
toyota = arrange(toyota, increasing = (toyota$Date))
# Break the datasets into the training sets and the test sets.
honda.train = honda[1:1264, names(honda)]
toyota.train = toyota[1:1264, names(toyota)]
honda.test = honda[1265:5164, names(honda)]
toyota.test = toyota[1265:5164, names(toyota)]
# Define some of the objects that will be needed for plotting the stock ratio with the mean lines and different
# measures of sigma around the mean.
stockratio.train = honda.train$Adj.Close / toyota.train$Adj.Close
m.train = mean(stockratio.train)
sd.train = sd(stockratio.train)
stockratio.test = honda.test$Adj.Close / toyota.test$Adj.Close
m.test = mean(stockratio.test)
sd.test = sd(stockratio.test)
# Make a plot showing the historical ratio of closing prices, add lines to signify the mean and different standard
# deviations from the mean.
plot(stockratio.train, ylab = 'Ratio (Honda / Toyota)', main = 'Historical Ratio (Training Data)', type ='l')
abline(h = m.train, col = 'red', lwd = 1.8)
abline(h = m.train + .77 * sd.train, col = 'darkorange', lwd = 1.5, lty = 5)
abline(h = m.train - .77 * sd.train, col = 'darkorange', lwd = 1.5, lty = 5)
abline(h = m.train + 1 * sd.train, col = 'royalblue', lwd = 1.5, lty = 5)
abline(h = m.train - 1 * sd.train, col = 'royalblue', lwd = 1.5, lty = 5)
legend('topleft', c('Mean', '+/- (Optimal k) * sd', '+/- 1 sd', 'Opening/Closing Positions'),
col = c('red', 'darkorange', 'royalblue', 'green'), lty = c(1,5,5), lwd = c(1.8,1.8,1.8,8), bty = 'n')
points(find.points(honda.train, toyota.train, .77),stockratio.train[find.points(honda.train, toyota.train, .77)],
col = 'green', pch = 1, lwd = 4)
# Do the same plot, but for the test data.
plot(stockratio.test, ylab = 'Ratio (Honda / Toyota)', main = 'Ratio (Test Data)', type = 'l')
abline(h = m.test, col = 'red', lwd = 1.8)
abline(h = m.test + .77 * sd.test, col = 'darkorange', lwd = 1.5, lty = 5)
abline(h = m.test - .77 * sd.test, col = 'darkorange', lwd = 1.5, lty = 5)
abline(h = m.test + 1 * sd.test, col = 'royalblue', lwd = 1.5, lty = 5)
abline(h = m.test - 1 * sd.test, col = 'royalblue', lwd = 1.5, lty = 5)
legend('top', c('Mean', '+/- (Optimal k) * sd', '+/- 1 * sd', 'Opening/Closing Positions'),
col = c('red', 'darkorange', 'royalblue', 'green'), lty = c(1,5,5,8), lwd = c(1.8,1.8,1.8,8), bty = 'n')
points(find.points(honda.test, toyota.test, .77), stockratio.test[find.points(honda.test, toyota.test, .77)],
col = 'green', pch = 1, lwd = 4)
# Make a plot comparing the historical prices of the two stocks. Then make one comparing the prices of the two stocks
# for our test data.
plot(honda.train$Adj.Close, col = 'orange', type = 'l', main = 'Historical Prices (First Five Years)',
xlab = 'Trading Day Index (April 13, 1993 - April 13, 1998)', ylab = 'Share Price ($)',
ylim = range(honda.train$Adj.Close, toyota.train$Adj.Close))
lines(toyota.train$Adj.Close, col = 'royalblue')
legend('topleft', c('Honda', 'Toyota'), col = c('orange', 'royalblue'), lty = 1, lwd = 2, bty = 'n')
plot(honda.test$Adj.Close, type = 'l', col = 'orange', main = 'Stock Prices for Test Data (Remaining Years)',
xlab = 'Trading Day Index (April 14, 1998 - October 18, 2013)', ylab = 'Share Price ($)',
ylim = range(honda.test$Adj.Close,toyota.test$Adj.Close))
lines(toyota.test$Adj.Close, col = 'royalblue')
legend('topleft', c('Honda', 'Toyota'), col = c('orange', 'royalblue'), lty = 1, lwd = 2, bty = 'n')
# Here is my code for running the profit of the simulations, and my attempt to run each simulation several times.
# I include all the cases I mentioned in my report. Sadly, there is no plot :(
# simtotalprofit(stocksim(.99, .9, .01, .01)[,1],stocksim(.99, .9, .01, .01)[,2], k)
# x = sapply(1:1000, function(x) stocksim(.99, .9, .01, .01))
# y = sapply(x, simtotalprofit(x[1:(length(x)/2)],x[(length(x)/2):length(x)], k))
# Psi = .1; beta's and k vary.
simtotalprofit(stocksim(.99, .1, .01, .01)[,1],stocksim(.99, .1, .01, .01)[,2], .5)
simtotalprofit(stocksim(.99, .1, .01, .01)[,1],stocksim(.99, .1, .01, .01)[,2], 1)
simtotalprofit(stocksim(.99, .1, .01, .01)[,1],stocksim(.99, .1, .01, .01)[,2], 1.5)
simtotalprofit(stocksim(.99, .1, .01, .01)[,1],stocksim(.99, .1, .01, .01)[,2], 2)
simtotalprofit(stocksim(.99, .1, .01, -.01)[,1],stocksim(.99, .1, .01, -.01)[,2], .5)
simtotalprofit(stocksim(.99, .1, .01, -.01)[,1],stocksim(.99, .1, .01, -.01)[,2], 1)
simtotalprofit(stocksim(.99, .1, .01, -.01)[,1],stocksim(.99, .1, .01, -.01)[,2], 1.5)
simtotalprofit(stocksim(.99, .1, .01, -.01)[,1],stocksim(.99, .1, .01, -.01)[,2], 2)
# Psi = .5; beta's and k vary.
simtotalprofit(stocksim(.99, .5, .01, .01)[,1],stocksim(.99, .5, .01, .01)[,2], .5)
simtotalprofit(stocksim(.99, .5, .01, .01)[,1],stocksim(.99, .5, .01, .01)[,2], 1)
simtotalprofit(stocksim(.99, .5, .01, .01)[,1],stocksim(.99, .5, .01, .01)[,2], 1.5)
simtotalprofit(stocksim(.99, .5, .01, .01)[,1],stocksim(.99, .5, .01, .01)[,2], 2)
simtotalprofit(stocksim(.99, .5, .01, -.01)[,1],stocksim(.99, .5, .01, -.01)[,2], .5)
simtotalprofit(stocksim(.99, .5, .01, -.01)[,1],stocksim(.99, .5, .01, -.01)[,2], 1)
simtotalprofit(stocksim(.99, .5, .01, -.01)[,1],stocksim(.99, .5, .01, -.01)[,2], 1.5)
simtotalprofit(stocksim(.99, .5, .01, -.01)[,1],stocksim(.99, .5, .01, -.01)[,2], 2)
# Psi = .9; beta's and k vary.
simtotalprofit(stocksim(.99, .9, .01, .01)[,1],stocksim(.99, .9, .01, .01)[,2], .5)
simtotalprofit(stocksim(.99, .9, .01, .01)[,1],stocksim(.99, .9, .01, .01)[,2], 1)
simtotalprofit(stocksim(.99, .9, .01, .01)[,1],stocksim(.99, .9, .01, .01)[,2], 1.5)
simtotalprofit(stocksim(.99, .9, .01, .01)[,1],stocksim(.99, .9, .01, .01)[,2], 2)
simtotalprofit(stocksim(.99, .9, .01, -.01)[,1],stocksim(.99, .9, .01, -.01)[,2], .5)
simtotalprofit(stocksim(.99, .9, .01, -.01)[,1],stocksim(.99, .9, .01, -.01)[,2], 1)
simtotalprofit(stocksim(.99, .9, .01, -.01)[,1],stocksim(.99, .9, .01, -.01)[,2], 1.5)
simtotalprofit(stocksim(.99, .9, .01, -.01)[,1],stocksim(.99, .9, .01, -.01)[,2], 2)
# k = seq(from = .5, to = 2.5, by = .5)
# density(simtotalprofit(stocksim(.99, .5, .01, -.01)[,1],stocksim(.99, .9, .01, .01)[,2], k))
rm(list=ls())
Delay1987_1989 = as.integer(readLines('ArrDelay_1987_1989.csv'))
setwd("~/250_Data")
Delay1987_1989 = as.integer(readLines('ArrDelay_1987_1989.csv'))
mean(Delay1987_1989)
mean(Delay1987_1989, na.rm = TRUE)
Delay1990_1999 = as.integer(readLines('ArrDelay_1990_1999.csv'))
mean(Delay1990_1999, na.rm = TRUE)
mean(Delay1990_1999, na.rm = TRUE)
sd(Delay1987_1989)
sd(Delay1987_1989, na.rm = TRUE)
Delay2000_2004 = as.integer(readLines('ArrDelay_2000_2004.csv'))
Delay2005_2007 = as.integer(readLines('ArrDelay_2005_2007.csv'))
Delay2008_2012 = as.integer(readLines('ArrDelay_2008_2012.csv'))
mean(Delay1987_1989) + mean(Delay1990_1999) + mean(Delay2000_2004) + mean(Delay2005_2007) + mean(Delay2008_2012) / 5
mean(Delay1987_1989, na.rm = TRUE) + mean(Delay1990_1999, na.rm = TRUE) + mean(Delay2000_2004, na.rm = TRUE) + mean(Delay2005_2007, na.rm = TRUE) + mean(Delay2008_2012, na.rm = TRUE) / 5
median(Delay1987_1989)
median(Delay1987_1989, na.rm = TRUE)
x = c(1,2,3,3,2,1)
median(x)
x = c(1,2,4,2,1)
median(x)
x = c(1,2,4,2)
median(x)
x = c(1,2,3,4)
median(x)
x = c(4,2,1,3)
median(x)
length(Delay1987_1989)
